
Starting the app for development:

1) Open Android Studio
2) Open emulator
3) run $ npm run android in code editor terminal

**If you make changes to files, you need to reload the emulator (reload in the menu or press 'rr') to see the updates.

Syncing and rebuilding for troubleshooting:

in android studio:
1) Build->Clean project
2) Build->Rebuild project
3) File->Sync Project Files with Gradle Files


-------

VIEWS:

-Main div component in react-native.  These do not scroll if content overflows viewport.  
***You need to use ScrollView or FlatList

-Dealing with blocking flexbox behavior in subcomponents wrapped in a View:

(View Wrapper in subcomponent that's imported into parent with flex: 1 container)
<View style={styles.container}>

container: {
    width: '100%', // this is set because the View wrapper in here is blocking the inherited flexbox behavior from the wrapper in the parent.
    alignItems: "center"
  },

Getting dynamic dimendsions:

// note - the dimensions calculation is left inline to dynamically calculate if device is rotated.
      <View style={[styles.container, { width: Dimensions.get("window").width * 0.8 }]}> 


========================

IMAGE COMPONENT:

-image components in react-native expect an object with a uri property to be passed in:

<Image source={{ uri: "uri/path" }}

TEXT:

-Text must be wrapped in a <Text> component

======================

Navigation:

-Use react-native-navigation package.

NOTE: Navigating back to a tab after visiting does NOT trigger componentDidMount() lifecycle method!  
Need to keep this in mind so you know that logic in this method will not run again on revisiting the tab
-Use componentDidUpdate for listening to props to run logic (such as redirects etc) conditionally

-Views that are used in navigation are called screens and are in the screens folder.  They are container components.

***React-native-navigation maintains a stack of pages for every app you start.
  -The top most page on the stack is the one which is visible.
  -You can push and pop pages to determine what is visible and where the back button goes.
  -The builtin navigator prop on any registered screen components exposes these methods: 
    props.navigator.push({ screen: <screen string>, title: <title>, passProps: <props to pass to pushed screen> });
    props.navigator.pop() 

----

In the main app.js file you need to register the screens and pass in the store:

    import { Navigation } from 'react-native-navigation';
    import { Provider } from 'react-redux';
    import AuthScreen from './src/screens/Auth/Auth';
    import SharePlaceScreen from './src/screens/SharePlace/SharePlace';
    import FindPlaceScreen from './src/screens/FindPlace/FindPlace';
    import configureStore from './src/store/configureStore';

    const store = configureStore();

    /*** REGISTER SCREENS ****/
    Navigation.registerComponent("my-app.AuthScreen", () => AuthScreen, store, Provider);
    Navigation.registerComponent("my-app.SharePlaceScreen", () => SharePlaceScreen, store, Provider);
    Navigation.registerComponent("my-app.FindPlaceScreen", () => FindPlaceScreen, store, Provider);

    /*** START AN APP ***/
    Navigation.startSingleScreenApp({
      screen: {
        screen: "my-app.AuthScreen", // <-- the unique string id assigned to the screen to use
        title: "Login" // <-- title displays in the navbar automatically added by the library
      }
    });

    FINALLY JUST IMPORT APP INTO THE ENTRY POINT FILE (INDEX.JS):
    
    import App from './App';

    ===================


  STYLING COMPONENTS:

  ***You cannot add styles directly to some React-Native elements like Buttons (Touchables) 
     You need to use a <View> component and set styles to that for styling those elements that can't accept a style prop.

  **Flexbox is used automatically by React-Native View components (you don't need to add display: flex)

  Ex:
    <TouchableOpacity>
        <View style={styles.searchButton}>
          <Text style={styles.searchButtonText}>Find Places</Text>
        </View>
      </TouchableOpacity>

  const styles = StyleSheet.create({
    searchButton: {
      borderColor: "orange",
      borderWidth: 3,
      borderRadius: 50,
      padding: 20
    }, ...
    

  CENTERING VERTICALLY AND HORIZONTALLY:

      <View style={styles.container}>
        <Text>Auth Screen</Text>
        <Button title="Switch to Login" />
        {/* Put inputs in separate container and set their width to 100% - you can reuse them in any container View and just set the width on the container */}
        <View style={styles.inputContainer}>
          <TextInput placeholder="E-mail Address" style={styles.input} />
          <TextInput placeholder="Password" style={styles.input} />
          <TextInput placeholder="Confirm Password" style={styles.input} />
        </View>
        <Button title="Submit" onPress={this.loginHandler} />
      </View>

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center"
  },
  inputContainer: {
    width: '80%'
  },
  input: {
    width: '100%' // <-- inputs are now reusable since the container will determine width,
  }
});

--

MAKING REUSABLE UI COMPONENTS:


*OVERWRITING STYLES: 

-In the default component pass an array of styles into the style prop and they will overwrite each other based on order 
(later entries overwrite previous entries).

Example: style=[styles.input, props.style]

const DefaultInput = props => (
  <TextInput 
    style={[styles.input, props.style]} 
    {...props} // this allows you to pass any props that would normally be supported by TextInput without having to explicitly set and grab them here.
  />
);

// this is overwritten by second element in the style array
const styles = StyleSheet.create({
  input: {
    width: '100%',
    borderWidth: 1,
    borderColor: "#eee",
    padding: 5,
    margin: 8
  }
});

================

HANDLE SCREEN ROTATION:

(Files to see full examples are PlaceDetail.js and AuthScreen component)

-Use the Dimensions API:
  listen to the "change" event and in the callback get access to the dimensions object which you can set state with styles 
  to use on components.

-Set separate rules in the stylesheet.create() for portrait and landscape state to take advantage of the optimizations from using styleSheet.create.  

class AuthScreen extends Component {
  state = {
    viewMode: Dimensions.get("window").height > 500 ? "portrait" : "landscape"
  };

  constructor(props) {
    super(props);

    Dimensions.addEventListener("change", this.updateStyles);
  }

  // You need to detach the change listener to prevent memory leak and prevent errors
  componentWillUnmount() {
    Dimensions.removeEventListener("change", this.updateStyles);
  }

  updateStyles = (dims) => {
    this.setState({
      viewMode: dims.window.height > 500 ? "portrait" : "landscape"
    });
  }



in styles = styleSheet.create() ...

  landscapePasswordContainer: {
    flexDirection: "row",
    justifyContent: "space-between"
  },
  portraitPasswordContainer: {
    flexDirection: "column",
    justifyContent: "flex-start"
  },

-On the components inline styles, conditionally set the style to the portrait or landscape rules based on state:

  <View style={styles.inputContainer}>
    <DefaultInput placeholder="E-mail Address" style={styles.input} />
    <View 
      style={ 
        this.state.viewMode === "portrait" 
          ? styles.portraitPasswordContainer 
          : styles.landscapePasswordContainer
      }
    >


See PlaceDetail.js for example of making elements stack on rotating to landscape view:
 -Add extra View wrapper to block "row" setting of landscape container around elements you want to stack  
  in landscape view.
 -Set flex: {Number} tomake the blocking view wrapper take up relative space to other elements (more, less or equal)

    ==================

    STYLING NAVIGATION TABS AND BUTTONS:

Docs: 
https://github.com/wix/react-native-navigation/blob/v1/docs/styling-the-navigator.md
https://github.com/wix/react-native-navigation/blob/v1/docs/top-level-api.md


-Use the tabsStyle property in the config object passed into Navigation.startTabBasedApp (on startMainTabs.js for example).

***FOR ANDROID: You need to do this in appStyle instead of tabsStyle

Ex:
  Navigation.startTabBasedApp({
        tabs: [
          ...other properties...
          tabsStyle: {
            tabBarSelectedButtonColor: "orange"
          },
          appStyle: {
            tabBarSelectedButtonColor: "orange" 
          }
          ...
        ] 
  });

// That sets the selected color, you can also change the color of the tab icon buttons as follows:

-You can style the navigator appearance and behavior by passing a navigatorStyle object. This object can be passed when 
the screen is originally created; can be defined per-screen by setting static navigatorStyle = {}; on the screen component; 

Ex:

class FindPlaceScreen extends Component {
  
  static navigatorStyle = {
    navButtonColor: "orange"
  };

  constructor(props) {
    super(props);

    ======================

ANIMATIONS:

(See FindPlace.js component)

1) import { Animated } from 'react-native';

2) Set value to start from (1 used here since the CSS style being animated is Opacity):
   state = {
     removeAnim: new Animated.Value(1)
   }
     
3) start and configure animation in handler with timing(<startValToChange>, <config obj>) method:
  
 placesSearchHandler = () => {
    Animated.timing(this.state.removeAnim, {
      toValue: 0,
      duration: 500,
      useNativeDriver: true
    }).start();
  };


Note: Animated.timing().start() can take a callback to run after the animation is completed.

Ex:

  Animated.timing(this.state.removeAnim, {
    toValue: 0,
    duration: 500,
    useNativeDriver: true
  }).start(() => {
    this.setState({
      placesLoaded: true
    });
    this.placesLoadedHandler(); // load another animation to start for ex. to fade in a list
  });


4) Wrap the component you want to animate with a special comp provided by Animated API: <Animated.View>.
Pass in the value assigned with new Animation.Value() to the style prop to the CSS property you want to animate.

      <Animated.View 
        style={{
          opacity: this.state.removeAnim
        }}
      >
        <TouchableOpacity onPress={this.placesSearchHandler}>
           ...content
        </TouchableOpacity>
      </Animated.View>

-------------------

-Inperpolating properties: you can change the values used for the start and end value of the animation by using
Animated.Value(<Value>).intperolate({ inputRange: <Original Range> outputRange: <Range to replace values with> });

On the value instantiated with new Animated.Value() you can attach an .interpolate() method which you can use to change 
the order of the values being transitioned.  

-You need to provide an input range (matches the values being used (the one passed into new Animated.Value() and the one 
used in the Animated.timing() handler toValue property) and an output range where you specify what values to replace the 
respective input values (based on index position) with.

Ex:

 style={{
          opacity: this.state.removeAnim,
          transform: [
            {
              scale: this.state.removeAnim.interpolate({
                inputRange: [0, 1],
                outputRange: [12, 1]
              })
            }
          ]
        }}

// The start value is 1 in the second index of inputRange, so 1 in the second index of outputRange will be used in place 
of the start value since that is what we want to start with.  12 will be used in place of 0, which is the toValue value 
specified in the handler to start the animation with Animated.timing().  

================

FORM INPUT AND VALIDATION:

See Auth.js screen

-You can use a valid prop and pass it to the input component from the parent form component to conditionally render
 styles for the input.

 Ex:

 -Pass touched and valid props to the input from state of parent form component:

  <DefaultInput 
    placeholder="E-mail Address" 
    style={styles.input} 
    value={this.state.controls.email.value}
    onChangeText={(val) => this.updateInputState('email', val)}
    valid={this.state.controls.email.valid}
    touched={this.state.controls.email.touched} // prevent invalid styles before user interaction
  />

  // Update the touched and valid state with the onChangeText handler on the input


 const styles = StyleSheet.create({
  invalid: {
    backgroundColor: '#f9c0c0',
    borderColor: 'red'
  }
});

<TextInput 
  style={[styles.input, props.style, !props.valid && props.touched ? styles.invalid : null]}
  underlineColorAndroid="transparent" 
  {...props} 
  />

  ----------

Auth Submit handler:

1) create auth action to dispatch auth data
2) connect auth component and map dispatch of try auth action to props
3) onSubmit handler should dispatch action with auth data passed in

-------------

CONFIGURING TEXTINPUTS:

https://facebook.github.io/react-native/docs/textinput

-You can set things like 
autoCorrect - good to dsiable on password fields, 
autoCapitalize - good to disable on password fields, 
keyboardType (allows you to specify which kind of keyboard pulls
up)

keyboardType values that work cross platform:
default
number-pad
decimal-pad
numeric
email-address
phone-pad

secureTextEntry - used to hide the password on input

Ex:

  <TextInput
    // react-native attributes you can use with TextInput to configure behavior of the keyboard:
    autoCapitalize={false}
    autoCorrect={false}          <--good to disable autoCorrect for password field
    keyboardType="email-address"
  />

------

TWO THINGS TO DO WHEN WORKING WITH SOFT KEYBOARD:

1) PUSH VIEW OUT OF THE WAY OF KEYBOARD:

  **Use the KeyboardAvoidingView component to move other elements to avoid being blocked by the keyboard when it's 
    pulled up.

    Docs: https://facebook.github.io/react-native/docs/keyboardavoidingview

    Note: this component can have some strange behavior sometimes - there is a note in the docs about differeing behavior
    on android and ios: Android and iOS both interact with this prop differently. Android may behave better when given no 
    behavior prop at all, whereas iOS is the opposite.

  -import the component and wrap your ui with it so your view elements are pushed up when the keyboard appears:
  -define the behavior to be used to push elements out of the way - "padding" is recommended to add padding at the bottom
   of page when keyboard in view.

Ex: 
  import { KeyboardAvoidingView } from 'react-native';

  <KeyboardAvoidingView style={styles.container} behavior="padding">
    ... your UI ...
  </KeyboardAvoidingView>

Note on using with ScrollView:
  The problem just is the ScrollView . Your content won't scroll up automatically - but you can do that manually. 
  So the input can be made visible.
  Once you close the keyboard though, the padding is likely to stick around.
  That's because ScrollView  + KeyboardAvoidingView  don't work together very well.

  Check the following thread for a discussion on this + possible workarounds: 
  https://github.com/facebook/react-native/issues/10765

  try this:
  <KeyboardAvoidingView behavior={'padding'} style={{flex: 1}}>
  {...header}
    <ScrollView>
      {...rows}
    </ScrollView>
  {...footer}
</KeyboardAvoidingView >

---

2) USE KEYBOARD API FOR CONFIGURING KEYBOARD BEHAVIOR TO CLOSE WHEN USER PRESSES OUTSIDE OF IT:

https://facebook.github.io/react-native/docs/keyboard

-To make the keyboard disappear when user presses somewhere else on the screen, use static dismiss() method
-Use TouchableWithoutFeedback component with this since you don't want to have effects on the screen for the press

Wrap the parts of your view outside of the keyboard in TouchableWithoutFeedback and make onPress reference the 
Keyboard.dismiss method.

Note: don't wrap <KeyboardAvoidingView> in the touchable or it will cause it to break.

Ex:
 <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
   ...Only one child here
 </TouchableWithoutFeedback>


 ====================

 USING MAPS:

 -React-Native-Maps by AirBNB: https://github.com/react-native-community/react-native-maps/blob/master/docs/installation.md
 (this requires a billing acct with Google) Alternative: MAPBOX for React-Native: https://www.mapbox.com/help/first-steps-react-native-sdk/

 *Follow the instructions in the docs for setup

 Note: Replace the implementation project(':react-native-maps') line in android/app/build.gradle with the blocked
       for importing Google Play services.
         (example: implementation(project(':react-native-maps')){
                    exclude group: 'com.google.android.gms', module: 'play-services-base'
                    exclude group: 'com.google.android.gms', module: 'play-services-maps'
                    }
                    implementation 'com.google.android.gms:play-services-base:10.0.1'
                    implementation 'com.google.android.gms:play-services-maps:10.0.1')

Create an API Key for Google Maps: search for Google Maps Android API Key and create a new project to generate 
a key.  

-Make sure to copy the Meta tag from the docs into your AndroidManifest.xml file at the bottom or top level of the 
<Application> wrapper (maybe next to <activity>) and paste in your api key.

Ex:
   <application>
      <activity android:name="com.facebook.react.devsupport.DevSettingsActivity" />
      <meta-data
        android:name="com.google.android.geo.API_KEY"
        android:value="Your Google maps API Key Here"/>
    </application>

    -You'll need to install open Gapps on Genymotion - start the emulator and click the open GApps button at the top 
     right of the phone emulator window.


===================

REACT-NATIVE-IMAGE-PICKER

Docs: https://github.com/react-native-community/react-native-image-picker

-This library creates a menu to access local photo library or take a new photo.

install:

$ npm install --save react-native-image-picker

Follow instructions here: 
https://github.com/react-native-community/react-native-image-picker/blob/master/docs/Install.md

In newer Android SDKs (>23), you actually need to ask for permission from within the app - 
otherwise trying to access the camera will crash the app.

The react-native-image-picker library will hopefully soon be updated to also cover this case and automatically 
request permissions (see: https://github.com/react-community/react-native-image-picker/issues/581).

Until this is done, you can add the following code to your project as a temporary workaround (if you're
 facing issues): https://gist.github.com/pvanliefland/92046b17444a8760475e7cc0dae4fec7

Add this code in a file which you add to your project and then import the adjusted ImagePicker 
from that file and use it in your app.

-Use builtin ImagePicker.showImagePicker to show the alert to choose an image menu:

-use builtin props on response in second arg to check if user canceled the selection or if there was an error:

Example handler:
  pickImageHandler = () => {
      // builtin method with react-native-image-picker library to show menu to pick an image from photo lib
      ImagePicker.showImagePicker(
        {title: "Pick an Image"},
        // second arg is response from selection
        res => {
          // used props exposed by the library to check for cases to handle:
          if (res.didCancel) {
            console.log("User Cancelled.");
          } else if (res.error) {
            console.log("Error", res.error);
          } else {
            // <Image> component expects a uri property passed into source prop.  Set this so when it pulls from 
            // state it gets what it expects.
            this.setState({
              pickedImage: {
                uri: res.uri,
                base64: res.data
              }
            });
          }
        }
      );
    };

    <Button title="pick image" onPress={this.pickImageHandler} />

(See PickImage.js)

**On the res object you can access the image via res.uri or as a Base 64 encoded string (string representation 
of the image) which can be used to send it over the wire and store it on a server for example on res.data.

Note: you can improve performance if you don't need this option and set noData=true in the first arg object passed
in to ImagePicker.showImpagePicker({ title: "pick image", noData: true }, ...)


Restricting width and height of images:

-You can provide a max height and width restriction to ImagePicker.showImagePicker() in the config obj passed in
which will reduce the size of the image if larger than those

***This speeds up upload time:

ImagePicker.showImagePicker({ title: "Pick an image", maxWidth: 800, maxHeight: 600 })


================

HTTP REQUESTS WITH REACT-NATIVE:

-Can use Fetch API or library like axios.  fetch and XMLHttpRequest are supported by RN.

USING THE FETCH API:

fetch("<url endpoint>"); <-- get request
fetch("<url endpoint>", {
  method: "POST",
  body: JSON.stringify({...Data}) <-- body must be JSON string
})
.catch(err => console.log(err))
.then(res => res.json()) <-- need to get data from response with .json()
.catch(err => {
  // catches 4xx and 5xx errors as well when at end of chain
})

**IMPORTANT: Catch blocks at the top will only catch failed network requests and not 4xx or 5xx errors!???

then()-catch()-then() makes sense if you have code you want to execute after catching an error - 
that is a scenario where it is of course find to use that pattern.

handling 4xx and 5xx errors (safer way checking ok property on returned responses using fetch):
https://www.tjvantoll.com/2015/09/13/fetch-and-errors/

function handleErrors(response) {
    if (!response.ok) {
        throw Error(response.statusText);
    }
    return response.json();
}

fetch("http://httpstat.us/500")
    .then(handleErrors)
    .then(function(response) {
        console.log("ok");
    }).catch(function(error) {
        console.log(error);
    });



*You need to add a catch block at the end of the chain to catch 4xx and 5xx errors!

----

UPLOADING FILES AND STORING IN DATABASE:

1) POST HTTP Request to endpoint on back end which passes base64 string representation of file, or file data.
2) Endpoint handler sends file data to a bucket or file storage system (use Node's fs module)
3) Url for the file generated (use uuid for unique filenames) and used in second request to Database endpoint  
   To store the URL in the database for accessing file on the front end.


----------

GOOGLE CLOUD FUNCTIONS TO STORE FILES WITH FIREBASE:

-Storage Javascript SDK does not currently work well with React-Native.  You can use cloud functions to access 
storage API in the function and store uploaded images, files, etc.

CLOUD FUNCTION SETUP:

1) Install firebase tools globally:
npm install -g firebase-tools

// firebase-tools is a CLI and just makes it easy to write and deploy a cloud function.

2) In project root folder, run:
$ firebase init

// this asks you what you want to use. select option Functions with arrow keys and hit space to check it. 
then hit enter.

Follow prompts - choose project, options and install npm dependencies.
A firebase.json and firebase.rc file is created.

A functions folder is created.  You can write cloud functions in the index.js file.

3) install the storage SDK:
npm install @google-cloud/storage

// update to latest npm with npm install -g npm to solve errors

4) install cors package:
npm install --save cors


Example cloud function to store files:


const functions = require("firebase-functions");
const cors = require("cors")({ origin: true });
const fs = require("fs");
const UUID = require("uuid-v4");
 
const gcconfig = {
  projectId: "YOUR_PROJECT_ID",
  keyFilename: "awesome-places.json"
};
 
const gcs = require("@google-cloud/storage")(gcconfig);
 
// // Create and Deploy Your First Cloud Functions
// // https://firebase.google.com/docs/functions/write-firebase-functions
//
exports.storeImage = functions.https.onRequest((request, response) => {
  return cors(request, response, () => {
    const body = JSON.parse(request.body);
    fs.writeFileSync("/tmp/uploaded-image.jpg", body.image, "base64", err => {
      console.log(err);
      return response.status(500).json({ error: err });
    });
    const bucket = gcs.bucket("YOUR_PROJECT_ID.appspot.com");
    const uuid = UUID();
 
    // make sure to return this so that the cloud function knows when the promise is done - otherwise it could time out early.
    return bucket.upload(
      "/tmp/uploaded-image.jpg",
      {
        uploadType: "media",
        destination: "/places/" + uuid + ".jpg",
        metadata: {
          metadata: {
            contentType: "image/jpeg",
            firebaseStorageDownloadTokens: uuid
          }
        }
      },
      (err, file) => {
        if (!err) {
          return response.status(201).json({
            imageUrl:
              "https://firebasestorage.googleapis.com/v0/b/" +
              bucket.name +
              "/o/" +
              encodeURIComponent(file.name) +
              "?alt=media&token=" +
              uuid
          });
        } else {
          console.log(err);
          return response.status(500).json({ error: err });
        }
      }
    );
  });

  ====================

  CREATING LOADING SPINNERS WITH ACTIVITY INDICATOR:

  -use react-native ActivityIndicator component (import it)
  -create a let to hold the component that changes when LOADING
  -connect component to state to check loading and overwrite let with ActivityIndicator if true
  -render the let value in the component

render() {
  let submitButton = (
    <ButtonWithBackground>
      Submit
    </ButtonWithBackground>
  );

  if (this.props.isLoading) {
    submitButton = <ActivityIndicator />
  }

  ------------------------------

  AUTHENTICATION:

  Backend Server:
  - exposes two endpoints (create new user, or signin existing user)
  - Client app sends request to either create a new user or sign an existing user in.

  -The server is stateless - A session is not used in authentication with React-Native apps.
  - Instead of a session, a JWT token is sent back from the server.  It is created in a way so that only the 
    server can verify if it is valid or not ( you can't just copy it or fake it on the front end)
  - This token is stored in the app in storage (AsyncStorage) and is used with a request to a protected resource.

  - On the backend you need logic to create users, retrieve existing users, and create JWT tokens.

  --------

  USING AUTHENTICATION WITH FIREBASE:

  -Firebase offers endpoints to create users, sign users in and get auth tokens.

  Docs: https://firebase.google.com/docs/reference/rest/auth/

  1) Go to Firebase project on firebase site and go to Authentication->Signin  Method, and enable the Email/Password method.

  -This exposes endpoints which are in docs at https://firebase.google.com/docs/reference/rest/auth/#section-create-email-password
  to sign up and create users.

  Ex: 
  Sign up user endpoint: https://www.googleapis.com/identitytoolkit/v3/relyingparty/signupNewUser?key=[API_KEY]
  Sign in user endpoint: https://www.googleapis.com/identitytoolkit/v3/relyingparty/verifyPassword?key=[API_KEY]
  (both take same params and content-type - only difference is the url)

  -You send a body with params:
  email	string	The email for the user to create.
  password	string	The password for the user to create.
  returnSecureToken	boolean	Whether or not to return an ID and refresh token. Should always be true.

  * You also need to set headers in the fetch request: headers: { "Content-Type": "application/json" }


  2) Create action generators to make auth requests.
    -one for Signing up user 
    -one for logging in user.
    Note: you can use one action that just checks the signin or login state since the payload for both endpoints is the same  
          the only thing that is different is the endpoint which you can assign to a let and check the auth mode in state
          to determine which endpoint to send request to.

  3) if response from firebase auth endpoint request has no error prop then start a tab app
  .then(parsedRes => {
      dispatch(uiStopLoading());
      // errors on response will not throw catch from Firebase.  You need to check for an error prop on the response.
      if (parsedRes.error) {
        alert("Auth failed. Please try again.");
      } else {
        // start a tab app if user was created successfully in firebase
        startMainTabs();
      }
    })


  ERROR HANDLING:

  -A catch will not be thrown if the response from Firebase has an error. 
  -You need to check the .error prop on the response
  -using fetch, you need to check res.ok prop and throw an error if it's falsey - this will trigger the next possible catch block
  -error object on firebase response will have message prop you can use and status codes to check as well.

  Ex: 

  .then(res => {
      if (res.ok) {
        return res.json();
      } else {
        throw (new Error());
      }
    })

    .. place catch block at the end of the promise chain which will now catch 400 and 500 errors as well.

  4) Set up auth tokens and rules in Firebase:
     -Go to Firebase console->Database->Rules and change read and write rules.
     -auth is a special variable provided by Firebase.  If it is null, then the user is not authenticated.

    {
      "rules": {
        ".read": "auth != null",
        ".write": "auth != null"
      }
    }

    Authenticating Rest requests to Firebase: https://firebase.google.com/docs/database/rest/auth

    *You can authenticate requests by appending a auth query parameter to the endpoint which is set to the idToken
    on the response sent.
    Ex: https://<DATABASE_NAME>.firebaseio.com/users/ada/name.json?auth=<ID_TOKEN>

    -On the response object sent back from requests to the firebase auth endpoints, you get an idToken prop.
    -Store this idToken - for example in the redux store.
    (create an action to store the token in the store i.e. AUTH_SET_ACTION etc.)

    *The response.idToken prop (after it's parsed) should be checked, and user should not be authenticated and authorzied if
    this value is not present.  i.e. if (!parsedRes.idToken) { throw error... } else { login and redirect, etc... }

    -To get the token stored in state and use in your actions, turn the thunk async action to accept 2 params - dispatch, getState
    Ex:
      return (dispatch, getState) => {
        const token = getState().auth.token;
        // check if token is falsey and maybe throw error (not necessary here since the check occurs in authHandler before this)
        if (!token) {
          return;
        }
        ...

    - use the token in protected operations in the app in the firebase url set to an auth query param
      return fetch("https://react-practice-app-55aac.firebaseio.com/places.json?auth=" + token)

      *** MORE REUSABLE WAY TO WORK WITH AUTH TOKENS:

      Create an action to get the token from state and use it as a helper function.  return a promise which resolves with a 
      valid token, or rejects otherwise.

      Ex:
        export const authGetToken = () => {
          return (dispatch, getState) => {
            const promise = new Promise((resolve, reject) => {
              const token = getState().auth.token;
              if (!token) {
                reject();
              } else {
                resolve(token);
              }
            });
            return promise;
          };
        };

        -use this in other protected calls to inject the token in the action generators before the other code.
        -place the request (fetch) inside the then block to get the token and append it to the url.
        (remember to return the fetch call to continue in the promise chain with the response)

        dispatch(authGetToken())
          .then(token => {
            return fetch("https://react-practice-app-55aac.firebaseio.com/places.json?auth=" + token);
          })
          .catch(err => {
            alert("No valid token found.");
          })
          .then( ... code to run )
  
--

AUTHENTICATING CALLS TO CLOUD FUNCTION ENDPONITS:

-This is separate from Firebase auth and you need separate logic for it.  You don't append an auth query param for these
 endpoints, instead you need to assign an Authorization header on the request and set it to "Bearer <token>", and then
 check for it in the function code using firebase-admin helper to verify it.

-Create an authorization header in the function file (i.e. functions/index.js)

In the cloud funtion code at the top make checks on the authorization header which will have the token if present:

exports.storeImage = functions.https.onRequest((request, response) => {
 cors(request, response, () => {
   // check if the header is present and if it follows standard Bearer format convention
   if (!request.headers.authorization || request.headers.authorization.startsWith("Bearer ")) {
     console.log("no token present.");
     response.status(403).json({ error: "Unauthorized"});
     // **Exit the function!
     return;
   }

   -get the value of the token:
     let idToken;
    // split the header value to get the token as the second element in the returned array - 
    // separate it from the Bearer part (remember to add the space).
    idToken = request.headers.authorization.split("Bearer ")[1];


CHECK VALIDITY OF THE TOKEN:

*Check the validity of the token with a builtin package that comes with Firebase cloud functions:
  // this is a built in package that you can use to verify tokens (you don't need to npm install it, it comes with firebase functions)
  const admin = require("firebase-admin");

- You need to initialize the admin helper.  pass in the json key file in the functions folder.  Make sure you require it.

admin.initalizeApp({
  credential: admin.credential.cert(require("./react-native-app.json"))
});

-verify the token with the admin helper (it is async, so pass in code to continue with into a then block.  The then block will
  fail if the token is not verified.):

  idToken = request.headers.authorization.split("Bearer ")[1];
  
  admin.auth().verifyIdToken(idToken)
    .then(() => {
      ...code to execute if token is verified...
    })
    .catch(err => {
      ...handle error/log
      response.status(403).json({ error: "Unauthorized."});
    });

*Redeploy the function with firebase deploy in the terminal


----------

STORING TOKENS IN ASYNC STORAGE:

AsyncStorage Docs: https://facebook.github.io/react-native/docs/asyncstorage

AsyncStorage is a helper that allows you to store key/value pairs and will automatically pick the right database system
depending on the device it is run on (i.e. SQLite or RockDB for android)
*Returns a promise.

NOTE: for error handling, you always need to check if the value is not null in the then blocks since this will not trigger a 
catch block to fire - catch blocks only fire for connection related errors.

Async storage only accepts strings as values - make sure to parse stored values accordingly when setting or getting.

-Done so user does not have to sign back in after closing the app and going back to it if they have a valid token.

-You can set the expiration of a token in the response from Firebase on res.expiresIn = the value is a string in seconds.

-Store the token in AsyncStorage in addition to the redux store so if the app is closed and re-opened it can be accessed 
(since it will be cleared from the redux store at that point)

Create an async thunk action generator in auth.js actions file to store token in the redux store and in async storage.

1) import AsyncStorage in the actions file: import { AsyncStorage } from "react-native";

2) Create action generator to dispatch setting the token in the store and also storing it with AsyncStorage.
   This action generator dispatches a separate action for storing the token in redux (later in notes, see full example
   with checking the expiration of the token and checking for a refresh token)

Ex:
  export const authStoreToken = token => {
    return dispatch => {
      dispatch(authSetToken(token));
      // key can be any string you want, then set the token as the value in the second arg.
      AsyncStorage.setItem("rn:auth:authToken", token);
    };
  };

3) Getting the token from AsyncStorage:

-in the action to retrieve or get the token from the store, instead of exiting or rejecting immediately on not finding a token
, also add a check to check the AsyncStorage.

Ex:

  export const authGetToken = () => {
    return (dispatch, getState) => {
      const promise = new Promise((resolve, reject) => {
        const token = getState().auth.token;
        if (!token) {
          // check async storage before rejecting totally:
          AsyncStorage.getItem("rn:auth:authToken")
            .catch(err => reject())
            .then(tokenFromStorage => {
               // need to check if null since catch will only catch timeout or connection related errors and not 
               //  fire if token is null.  Remember to return out of the function
              if (!tokenFromStorage) {
                reject();
                return;
              }
              // set it in redux
              dispatch(authSetToken(tokenFromStorage));
              resolve(tokenFromStorage);
            });
        } else {
          resolve(token);
        }
      });
      return promise;
    };
  }

GETTING TOKEN FROM ASYNCSTORAGE IF APP IS CLOSED AND RELAUNCHED:

-Check for the token in the ComponentDidMount lifecycle hook on the home/login auth screen.
(ComponentDidMount will not be executed if the user puts the app in the background and comes back to it. 
It will be executed if the user exits the app and reloads and starts it)

In componentDidMount, dispatch an action that checks for the token in AsyncStorage - if it is found, then set it in the redux store
and redirect the user (by starting the tabs app with screens etc.)

Action generator:


export const authAutoSignin = () => {
  return dispatch => {
    dispatch(authGetToken())
    .then(token => {
      startMainTabs();
    })
    .catch(err => console.log("Failed to get token."))
  };
}

in component:

 componentDidMount() {
    // this checks for token in async storage and sets it in store if app is closed and relaunches.  It will start main tabs app
    // if token is found and valid.
    this.props.onAutoSignin();
  }

  -----------------

  SETTING AND MANAGING THE EXPIRATION OF STORED TOKENS:

  -The tokens can expire making them invalid and preventing the user from accessing the app with a valid token.

  -You need to store the time that the token expires using the expiresIn prop on the response sent from Firebase (which is a 
  number string in seconds).

  -In the action to store the token in AsyncStorage, pass in a second arg which is the expiresIn prop from the res.
   
  remember to parse the date (which is a number object) to a string with .toString() since you can only store strings.

  export const authStoreToken = (token, expiresIn) => {
    return dispatch => {
      const now = new Date();
      const expireTime = now.getTime() + (expiresIn * 1000); // convert to millisecs
      dispatch(authSetToken(token, expireTime));
      // key can be any string you want, then set the token as the value in the second arg.
      AsyncStorage.setItem("rn:auth:authToken", token);
      AsyncStorage.setItem("rn:auth:expiration", expireTime.toString());
    };
  };

   Store both the token and the expiration in redux - set up the authSetToken action accordingly with expire prop to send
    (in reducer)
    case AUTH_SET_TOKEN:
      return {
        ...state,
        token: action.token,
        expiration: action.expiration
      };


  -Now in the action to get the token from storage or redux, you need to check if the expiration date is in the future.
  *Remember to parse the item from AsyncStorage to a date since it is stored as a string for calculations with 
  by converting the string stored value to a number and passing it into new Date().
  Ex:
  ...after retrieving from async storage..
    .then((expiration) => {
            // parse value into a date because it is stored as a string:
            const parsedExpiration = new Date(parseInt(expiration));

  After parsing the value stored in async storage, check if it is greater than now (using new Date()), in which case it is valid ask
  the expiration date is in the future.

    .then((expiration) => {
      // parse value into a date because it is stored as a string (convert to number and pass in to new date):
      const parsedExpiration = new Date(parseInt(expiration));
      const now = new Date();
      if (parsedExpiration > now) {
        // set it in redux if not expired
        dispatch(authSetToken(fetchedToken));
        resolve(fetchedToken);
      } else {
        reject();
      }
    })

    Complete example (see actions/auth.js):

// checks for token in AsyncStorage and stores in redux store
export const authGetToken = () => {
  return (dispatch, getState) => {
    const promise = new Promise((resolve, reject) => {
      const token = getState().auth.token;

      /*** THIS COMPLEX BLOCK FIRES TO CHECK ASYNC STORAGE IF NONE FOUND IN REDUX ***/
      if (!token) {
        // declare let to use in different then blocks
        let fetchedToken;
        // check async storage before rejecting totally:
        AsyncStorage.getItem("rn:auth:authToken")
          .catch(err => reject())
          .then(tokenFromStorage => {
            fetchedToken = tokenFromStorage;
            // need to check if null since catch will only catch timeout or connection related errors and not fire if token is null
            if (!tokenFromStorage) {
              reject();
              return;
            }
            // check the expiration date of token then:
            return AsyncStorage.getItem("rn:auth:expiration");
          })
          .then((expiration) => {
            // parse value into a date because it is stored as a string (convert to number and pass in to new date):
            const parsedExpiration = new Date(parseInt(expiration));
            const now = new Date();
            if (parsedExpiration > now) {
              // set it in redux if not expired
              dispatch(authSetToken(fetchedToken));
              resolve(fetchedToken);
            } else {
              reject();
            }
          })
          .catch(err => {
            reject();
          });
      } else {
        resolve(token);
      }
    });
    

CLEARING STORAGE:

export const authClearStorage = () => {
    AsyncStorage.removeItem("rn:auth:authToken");
    AsyncStorage.removeItem("rn:auth:expiration");
    // return this to be able to chain a then in the logout action so that it only runs after the storage is cleared to prevent
    // a loop keeping the user logged in if storage wasn't cleared in time.
    return AsyncStorage.removeItem("rn:auth:refreshToken");
};

// this can be used if there is no valid or null id token returned from the fallback check to get a refresh token

=======================================

REFRESHING THE TOKEN:

docs: https://firebase.google.com/docs/reference/rest/auth/#section-refresh-token

**Store the expiration of the token in redux
 -You need to check not only if there is no token in redux before getting the token from async storage, but also if there is a token
   and it is expired, then you can also get a refresh token

   Ex in get token action:

      const expiration = getState().auth.expiration;

      /*** THIS COMPLEX BLOCK FIRES TO CHECK ASYNC STORAGE IF NONE FOUND IN REDUX ***/

        // You need to check for null token in redux, but also that the expiration date is not valid (in the past) so that the
        // refresh token process and async storage get token operations will fire if there is a token, but it's expired. 
        if (!token || new Date(expiration) <= new Date()) {

-The object returned from the calls to the auth endpoints provided by Firebase includes a refreshToken prop.

-You can use this to get a new valid token as a fallback in cases where the current token is no longer valid.
-Use the refreshToken to send another HTTP request to get a new valid token

-Check if you have a refreshToken on the response

1) Set the refreshToken value in AsyncStorage in the authStoreToken action generator:
export const authStoreToken = (token, expiresIn, refreshToken) => {
  return dispatch => {
    dispatch(authSetToken(token));
    const now = new Date();
    const expireTime = now.getTime() + (expiresIn * 1000); 
    AsyncStorage.setItem("rn:auth:authToken", token);
    AsyncStorage.setItem("rn:auth:expiration", expireTime.toString());

    AsyncStorage.setItem("rn:auth:refreshToken", refreshToken);
  };
};

2) Use the refresh token to get another valid token by sending a request to a firebase endpoint:
  Method: POST
  Content-Type: application/x-www-form-urlencoded
  Endpoint
  https://securetoken.googleapis.com/v1/token?key=[API_KEY]

  In the get Token action, add a request to get a new token with the refresh token in catch block if token from storage
  is invalid, then send request with the refresh token to get a new valid token:

return promise
      .catch(err => {
        // return this block so that the .then block to check token is not run before this finishes.
        return AsyncStorage.getItem("rn:auth:refreshToken")
          .then(refreshToken => {
            // make req using the refreshtoken to get a new valid token:
            return fetch("https://securetoken.googleapis.com/v1/token?key=" + API_KEY, {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
              },
              // note that the body must be in encoded form format and not json
              body: "grant_type=refresh_token&refresh_token=" + refreshToken
            })
          })
          .then(res => res.json())
          .then(parsedRes => {
            const { id_token, expires_in, refresh_token } = parsedRes;
            // the new id token will be on the id_token prop from refresh token req response
            if (id_token) {
              // store the new token and data received:
              dispatch(authStoreToken(id_token, expires_in, refresh_token));
              // return the token so that authAutoSignin can use it and pass it on to the next block to check if null or valid
              return id_token;
            } else {
              authClearStorage();
            }
          });
    })
    .then(token => {
      // this ensures that the catch block in authAutoSignin will fire if the token is null or invalid
      if (!token) {
        throw new Error();
      } else {
        // return valid token for authAutoSignin to use
        return token;
      }
    });

  };
};


============

LOGGING USER OUT:

-Create a handler that dispatches an action which clears AsyncStorage and removes token from redux store

1) export as a function the call that started the single page app in App.js so that you can recall it to start that app when 
user logs out.

Ex in App.js:
  export default () => {
      Navigation.startSingleScreenApp({
        screen: {
          screen: "my-app.AuthScreen", // <-- the unique string id assigned to the screen to use
          title: "Login" // <-- title displays in the navbar automatically added by the library
        }
      });
  }

2) in index.js where you import the app, call it since it is now wrapped in a function:

Ex in index.js:
  import App from './App';

  // execute as a function since it is wrapped in one in order to be re-used to sign user out:
  App();

3) in the auth actions file import the app call to start the single page app for the login screen:
import App from "../../../App";

4) Use it to call the auth screen to load after async storage is cleared in the main logout action:

export const authLogout = () => {
  return dispatch => {
    authClearStorage()
      .then(() => {
        // only call the auth screen app to load after storage is cleared (make sure to return AsyncStorage call in it's action to enable chaining)
        // execute the imported wrapped call to start a single page app from App.js for the auth screen when user signs out:
        App();
      });
    dispatch(authRemoveToken());
  };
};

5) Make action generator to remove auth token from store
  export const authRemoveToken = () => {
    return {
      type: AUTH_REMOVE_TOKEN
    };
  };

  In reducer just set it to null:
      case AUTH_REMOVE_TOKEN: 
      return {
        ...state,
        token: null,
        expiration: null
      };

6) import the authLogout action into the component with sign out button and connect it to redux store with mapDispatchToProps.
   dispatch the logout action in the signout component when signout button is pressed:

    (Ex from sideDrawer.js:)
   <TouchableOpacity onPress={this.props.onLogout}>

   *Remember to pass store, Provider to screen registration for connecting to redux in App.js
     Ex using React-native-navigation: 
      Navigation.registerComponent("my-app.SideDrawerScreen", () => SideDrawerScreen, store, Provider);





=============

OVERVIEW OF AUTH

Create actions:

 -main auth action- makes request to auth endpoint and stores the token (in both redux and async storage)
   -store token action - bundles storing token data in redux and in async storage

 -action to get token from redux store first or async storage if not found.  This action is dispatched inside an auto sign in action
  whcih can be dispatched in componentDidMount in main auth screen to sign user in and start main tabs app if valid token
  and in other actions that require it to send with a protected request

-action to set token in redux store and in AsyncStorage.  This action generator calls and dispatches a separate action to \
 store it in the redux store

------

 Complete example of get token action:
// checks for token in AsyncStorage and stores in redux store on app re-launch for example
export const authGetToken = () => {
  return (dispatch, getState) => {
    const promise = new Promise((resolve, reject) => {
      // retrieve from redux store first:
      const token = getState().auth.token;
      const expiration = getState().auth.expiration;

      /*** THIS COMPLEX BLOCK FIRES TO CHECK ASYNC STORAGE IF NONE FOUND IN REDUX ***/

      // You need to check for null token in redux, but also that the expiration date is not valid (in the past) so that the
      // refresh token process and async storage get token operations will fire if there is a token, but it's expired. 
      if (!token || new Date(expiration) <= new Date()) {
        // declare let to use in different then blocks
        let fetchedToken;
        // check async storage before rejecting totally:
        AsyncStorage.getItem("rn:auth:authToken")
          .catch(err => reject())
          .then(tokenFromStorage => {
            fetchedToken = tokenFromStorage;
            // need to check if null since catch will only catch timeout or connection related errors and not fire if token is null
            if (!tokenFromStorage) {
              reject();
              return;
            }
            // check the expiration date of token then:
            return AsyncStorage.getItem("rn:auth:expiration");
          })
          .then((expiration) => {
            // parse value into a date because it is stored as a string (convert to number and pass in to new date):
            const parsedExpiration = new Date(parseInt(expiration));
            const now = new Date();
            if (parsedExpiration > now) {
              // set it in redux if not expired
              dispatch(authSetToken(fetchedToken));
              resolve(fetchedToken);
            } else {
              reject();
            }
          })
          .catch(err => {
            //this will fire the promise.catch block to request a refresh token
            reject();
          });
      } else {
        resolve(token);
      }
    });

    // add a catch block to the promise before returning to handle clearing the async storage if token/values stored are invalid
    // or expired and to use a refresh token to get a new valid token.
    return promise
      .catch(err => {
        // return this block so that the .then block to check token is not run before this finishes.
        return AsyncStorage.getItem("rn:auth:refreshToken")
          .then(refreshToken => {
            // make req using the refreshtoken to get a new valid token:
            return fetch("https://securetoken.googleapis.com/v1/token?key=" + API_KEY, {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded",
              },
              // note that the body must be in encoded form format and not json
              body: "grant_type=refresh_token&refresh_token=" + refreshToken
            })
          })
          .then(res => res.json())
          .then(parsedRes => {
            const { id_token, expires_in, refresh_token } = parsedRes;
            // the new id token will be on the id_token prop from refresh token req response
            if (id_token) {
              // store the new token and data received:
              dispatch(authStoreToken(id_token, expires_in, refresh_token));
              // return the token so that authAutoSignin can use it and pass it on to the next block to check if null or valid
              return id_token;
            } else {
              authClearStorage();
            }
          });
    })
    .then(token => {
      // this ensures that the catch block in authAutoSignin will fire if the token is null or invalid
      if (!token) {
        throw new Error();
      } else {
        // return valid token for authAutoSignin to use
        return token;
      }
    });

  };
};


=============================

RESETTING PAGES, CLEARING FORMS ETC ON SUBMIT/BUTTON PRESS:

1) create reset method which sets state to the initial state

2) If you need to reset child components from a parent, assign a ref to it with a ref prop and then access the child's reset
   method attached to the ref.

   in child component define the reset by setting state to it's initial state (copy and paste if necessary).

   In parent, add ref on child to access reset for it:

    <PickImage onImagePicked={this.imagePickedHandler} ref={ref => this.imagePicker = ref}/>

  Call it in the parent attached to the ref:

    this.imagePicker.reset();


==================

USING FIREBASE TRIGGERS IN CLOUD FUNCTIONS TO DELETE STORAGE ITEMS:

Docs:
https://firebase.google.com/docs/functions/database-events

-These triggers occur when something changes in the database.

Hook triggers include:
onWrite(), which triggers when data is created, updated, or deleted in the Realtime Database.
onCreate(), which triggers when new data is created in the Realtime Database.
onUpdate(), which triggers when data is updated in the Realtime Database.
onDelete(), which triggers when data is deleted from the Realtime Database.

-in the response from uploading file to storage, inlcude a path to the file to send back to the client to use when deleting
a place so it can be referenced to also delete the image file in storage.
Make sure to store the filePath with the entry data in redux for referencing when dispatching the store action on the response
on the front end.

Ex:
in response set prop to the destination of the file:
imagePath: "/places/" + uuid + ".jpg"

on front end set this in the store with the entry in redux

-You can use the firebase triggers to delete the file in the storage bucket when a corresponding item in the database is deleted:

exports.deleteImage = functions.database.ref("/places/{placeId}").onDelete(snapshot => {
  const placeData = snapshot.val();
  const imagePath = placeData.imagePath;

  // get the name of the bucket by going to firebase project page->Storage->Get Started-> click Got it.
  // The name of the bucket to pass in is in the url after gs:// (i.e. gs://<Name To copy without gs://>)
  const bucket = googleCloudStorage.bucket("react-practice-app-55aac.appspot.com");

  // delete the file - pass in the path and then the function returns a promise:
  // make sure to return this so that the cloud function knows when the promise is done - otherwise it could time out early.
  return bucket.file(imagePath).delete()
    .then(res => {
      // ...send res if successful
    })
    .catch(err => {
      console.log(err);
      // handle errors etc. send res
    });
})


